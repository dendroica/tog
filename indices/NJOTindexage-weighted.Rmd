---
title: "Bluefish stratified arithmetic mean index - NEFSC trawl (Bigelow)"
author: "M Celestino"
date: "`r Sys.time()`"
output: word_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE,
                      cache = FALSE)
```

## Bluefish index standardization

### Step 1: Data processing

Load functions & libraries
```{r}
library(ggplot2, quietly = TRUE, verbose=FALSE)
library(readxl, quietly = TRUE, verbose=FALSE)
library(rmarkdown, quietly = TRUE, verbose=FALSE)
library(knitr, quietly = TRUE, verbose=FALSE)
```

### Generate index from catch records first (so we can get SE & CV)

Note that we need to get index from catch records so we can get SE and CV of index; we'll generate the same index from the length records to apportion the index into ages, but we don't get SE or CV from the index generated from the length records.
```{r, error=TRUE}
# calc stratified mean (using all data, not just the data used in dat, which has some records removed due to missing env data):
# stratified arithmetic mean:
a <-
   as.data.frame(read_xlsx(path="f:\\BF_WG\\FIG\\NEFSC\\NEFSC_Fall_Survey_Data_for_Std_V3.xlsx",
   sheet="BLUEFISH_FALL_BIG_SAW60_09_21",range="A63:AJ713",na="NA"))
head(a)

# new code to fix issue in 2022 data query (note, Tony fixed the raw data, so no need for this now):
#a[a$YEAR==2022,"NUMBER"] <-  
#   a[a$YEAR==2022,"NUMBER"]*a[a$YEAR==2022,"SWEPT_AREA_RATIO"]

unique(a$STRATUM)

# Get table of strata sizes (as long as no additional strata are added, should be able to use this
#  table in perpetuity for management track and data updates):
lookup <-
   as.data.frame(read_xlsx(path="f:\\BF_WG\\FIG\\NEFSC\\NEFSC_Fall_Survey_Data_for_Std_V3.xlsx",
   sheet="strata sizes",range="O1:P46",na="NA"))

inshore <- c(3020,3050,3080,3110,3140,3170,3200,3230,3260,3290,3320,3350,3380,3410,3440,3450,3460)

lookup <- lookup[is.element(lookup$STRATUM,inshore),] # want just the inshore strata for BIG index with continuity (inshore) strata
lookup$wts <- lookup$size/sum(lookup$size)

A <- merge.data.frame(a,lookup[,c("STRATUM","wts")],by.x="STRATUM",by.y="STRATUM",all=TRUE)

# verify that every year the same strata are sampled - check!
sapply(split(a,a$YEAR), function(x) {
   unique(x$STRATUM)
   }
   )

#dat <- A
A$Fish <- A$NUMBER # New NEFSC Bigelow calcs account for tow duration so not double standardizing for tow distance
                                              
plot(with(A, tapply(Fish,YEAR,mean,na.rm=TRUE)),type="o",ylab="Arith mean catch per tow")


   #mean (using only inshore strata):
   M <- with(A, tapply(Fish,list(STRATUM,YEAR),mean,na.rm=TRUE))
   #variance:
   V <- with(A, tapply(Fish,list(STRATUM,YEAR),var,na.rm=TRUE))


   # Workaround if a year-stratum combination has NA variance (i.e., from n= 1), pool mean variance from entire year:
   needVar <- which(is.na(V))
   if(length(needVar)>0) {
      allYears <- sort(unique(A$YEAR))
      # years of interest:
      yoi <- rep(allYears,each=nrow(lookup))[needVar]                           
      lookupTable <- data.frame(year=allYears,.var=colMeans(V,na.rm=TRUE))
         # The special case of all NAs in a given year:
         # If NaN, then pool timeseries mean variance
         if(any(is.nan(lookupTable$.var))) {
            mod <- which(is.nan(lookupTable$.var))
            lookupTable$.var[mod] <- mean(lookupTable$.var[-mod])
         }
      ans <- merge(lookupTable,data.frame(year=yoi,tmp=NA),by="year",sort=FALSE)
      V[which(is.na(V))] <- ans$.var
   }


   # possible workaround for strata not sampled in a given year, replace mean with 0
#   M[which(is.na(M))] <- 0

   N <- with(A, tapply(Fish,list(STRATUM,YEAR),length))
   
   
   # UCL
   UCL <-
   apply(M*lookup$wts,2,sum,na.rm=TRUE)+
      ((sqrt(apply(lookup$wts^2*V/N,2,sum,na.rm=TRUE)))*qnorm((1-0.95)/2,lower=FALSE))

   # stratified mean:
   .m <- apply(M*lookup$wts,2,sum,na.rm=TRUE)

   # LCL
   LCL <-
   apply(M*lookup$wts,2,sum,na.rm=TRUE)-
      ((sqrt(apply(lookup$wts^2*V/N,2,sum,na.rm=TRUE)))*qnorm((1-0.95)/2,lower=FALSE))

   SE <- sqrt(apply(lookup$wts^2*V/N,2,sum,na.rm=TRUE))
   CV <- SE/.m

   nom <- data.frame("Year"=sort(unique(A$YEAR)),"Index"=.m,SE,
      "LCI"=LCL,"UCI"=UCL,CV,"Method"="stratifiedMean")




ggplot(nom, aes(x=as.numeric(Year), y=Index, color=Method, shape=Method)) +
  geom_ribbon(aes(x=as.numeric(Year), ymin=LCI, ymax=UCI, fill=Method), alpha=0.5) +
  geom_line() + geom_point() +
  xlab("Year") + theme_bw()

```

### Generate index from length records to aportion into ages

We need the code below to apportion the index into ages (should give the same stratified mean as from catch records, above).
```{r, error=TRUE}
########################## Index from length records:

# Concatenation of Cruise6 [6 char], Stratum [leading zeros, 5 digits],
#  Tow [leading zeros, 3 digits] and STA values [leading zeros 4 digits].
library(foreign)
len <- read.dbf("C:/Users/jgorzo/OneDrive - New Jersey Office of Information Technology/Documents/data/tog/TOLENG.DBF")
catch <- read.dbf("C:/Users/jgorzo/OneDrive - New Jersey Office of Information Technology/Documents/data/tog/TOABUN.DBF") #Technology/Documents/data/tog/examples/NEFSC_Fall_Survey_Data_for_Std_V3.xlsx", #same as a in block above
 #  sheet="BLUEFISH_FALL_BIG_SAW60_09_21",range="A63:AJ713",na="NA")) # from v2 of the catch query
catch <- catch[catch$YEAR>1988,]
len <- len[len$YEAR>1988,]

#len2 <- as.data.frame(read_xlsx("C:/Users/jgorzo/OneDrive - New Jersey Office of Information Technology/Documents/data/tog/examples/blf_nefsc_trawl_lengths_mgmtTrk.xlsx",sheet="Sheet1",
#   range="A1:L12152"))

catch <- catch[as.numeric(substr(catch$CRUCODE,5,5)) %in% 4:5,]
#table(indata2$Month) # check
   
forMerge <- data.frame("STRATUM"=12:26,"stratum2"=rep(c("inner","middle","outer"),times=5))
w <- c(14.7,32.5,76.7,17.4,81.3,293,59.9,235.9,279.9,17.1,198.7,185.1,34,133.6,131.9)
forMerge <- cbind(forMerge, "STRATUM_AREA"=w)
indata <- merge(catch,forMerge)                                                # YEAR order gets shuffled here
indata2 <- indata[indata$stratum2=="inner",]# | indata2$stratum2=="middle"]
```

```{r}
A <- len[len$ID %in% indata2$ID,]

# Merge the catch records with length records
oceanLen <- merge(indata2,A,all=TRUE)

# Verify that expanded len freq sums to expanded catch (i.e., the length
#  records match the catch numbers):
# Check first few by hand:
oceanLen[1:25,c("ID","NUMBER","FREQUENCY")] # manually check a few

# Check to see if there are any NAs:
apply(apply(oceanLen[,c("LENGTH","FREQUENCY")],2,is.na),2,any) # yes, so need to change:

# Change missing lengths to 1cm:
oceanLen[is.na(oceanLen$LENGTH),"LENGTH"] <- 1
# Change missing frequencies to 0
oceanLen[is.na(oceanLen$FREQUENCY),"FREQUENCY"] <- 0


# Then automate to check all:
summary(
tmp <- sapply(split(oceanLen,oceanLen$ID), function(z) {
   z$NUMBER[1]-sum(z$FREQUENCY)
   }
)
) # pretty good! (+/- ~1e-13)
plot(tmp)                                                                       # note that Bigelow catch records are expanded somewhat differently than length records
oceanLen[is.element(oceanLen$ID,names(which(tmp>0))),]
oceanLen[is.element(oceanLen$ID,names(which(tmp<0))),]
rm(tmp)

# double check zeros:
oceanLen[oceanLen$NUMBER==0,c("NUMBER","FREQUENCY")]
################################################################################

yrs <- c(2022:2024) #unique(oceanLen$YEAR)
strata <- unique(oceanLen$STRATUM)
                               # use min/max below [vs length(yrs)] to account for missing years
out <- matrix(NA,nrow=100,ncol=length(min(yrs):max(yrs))) # nrow = lenghts = 1:100 cm         # output storage matrix
colnames(out) <- paste("x",min(yrs):max(yrs),sep="")

for(i in yrs) {

   # first, subset by individual year i:
   tmp <- oceanLen[oceanLen$YEAR==i,c("YEAR","STA","STRATUM","STRATUM_AREA","LENGTH","FREQUENCY")]
   #tmp <- tmp[tmp$LENGTH >= 29 & tmp$LENGTH < 61,]
   missingStrata <- (strata)[which(!(strata %in% tmp$STRATUM))]   # account for strata in which no bluefish were collected
   missingFLs <- which(!(1:100 %in% tmp$LENGTH))                  # account for length bins in which no bluefish were collected
   #missingFLs <- missingFLs[missingFLs >= 29 & missingFLs < 61]                                                               # these steps keep the output coherent across all strata


   # First, calculate average number of BF collected per length bin in every STRATUM:
   tmp2 <-
   lapply(split(tmp,tmp$STRATUM), function(z) {
      zz <- as.data.frame(tapply(z$FREQUENCY,list(z$LENGTH,z$STA),sum)) # table of length bin x STA
      n <- length(unique(z$STA)) # number of STAs sampled in stratum
      zzz <- apply(zz,1,sum,na.rm=TRUE)/n # mean number per length bin
      # Bundle everything together:
      data.frame("YEAR"=z[1,"YEAR"],"STRATUM_AREA"=z[1,"STRATUM_AREA"],
         "STRATUM"=z[1,"STRATUM"],
         "LENGTH"=as.numeric(names(zzz)),"meanFREQUENCY"=zzz)
      }
   )
   tmp2 <- do.call("rbind",tmp2)


   # Fill in missing strata and/or length bins:
   if(length(missingStrata)>0) {
      # frequency = 0 for strata and bins where no BF were collected:
      tmp3 <- rbind(tmp2,data.frame("YEAR"=tmp2[1,"YEAR"],
         "STRATUM_AREA"=NA,# catch = 0 for these strata, so STRATUM_AREA = NA is ok.
         expand.grid("STRATUM"=missingStrata,"LENGTH"=missingFLs),"meanFREQUENCY"=0))
      } else {
      # expand.grid above won't work if there are no strata in which no BF were collected
      # so need this step in that case (appending the missingFLs to an arbitrary stratum)
      tmp3 <- rbind(tmp2,data.frame("YEAR"=tmp2[1,"YEAR"],
         "STRATUM_AREA"=tmp2[which(is.element(tmp2$STRATUM,strata[1]))[1],"STRATUM_AREA"],
         "STRATUM"=strata[1],
         "LENGTH"=missingFLs,"meanFREQUENCY"=0))
      }

   # Create table of catch in each length bin across all strata (because of averaging above, there are no duplicate lengths within a single stratum, so summing below is ok)
   tmp4 <- as.data.frame(tapply(tmp3$meanFREQUENCY, list(tmp3$LENGTH,tmp3$STRATUM), sum))
   # Make sure strata are in the correct order for subsequent multiplication (note that AREA=NA for strata
   #  that were not sampled):
   lookup <- as.data.frame(t(sapply(split(tmp3,tmp3$STRATUM), function(z) {z[1,c("STRATUM","STRATUM_AREA")]})))
   if(!all(as.numeric(colnames(tmp4))-unlist(lookup[,"STRATUM"])==0)) {stop("strata misaligned")}

   # Calculate weighted mean across strata:
   out[,i-(min(yrs)-1)] <-
   apply(tmp4,1,function(z) {
      sum(z * unlist(lookup[,"STRATUM_AREA"]),na.rm=TRUE) / sum(unlist(lookup[,"STRATUM_AREA"]),na.rm=TRUE)
      }                                                                                        #^^^^^^^^^^ needed to deal with strata that weren't sampled in a year
   )
}

colSums(out) # should equal stratified mean (& does!)
```

```{r}
################################################################################
# Age the index (specify directory where ALKs are):
indir <- "C:/Users/jgorzo/OneDrive - New Jersey Office of Information Technology/Documents/output/tog/alk/filled/opercboth"
alk2021numnj <- read.csv(file.path(indir, "NJNYB-ALK_2021_filled.csv"))
alk2022numnj <- read.csv(file.path(indir, "NJNYB-ALK_2022_filled.csv"))
alk2023numnj <- read.csv(file.path(indir, "NJNYB-ALK_2023_filled.csv"))
alk2024numnj <- read.csv(file.path(indir, "NJNYB-ALK_2024_filled.csv"))

alks <- list(alk2021numnj, alk2022numnj, alk2023numnj, alk2024numnj)
alks <- lapply(alks, function(y) {
  y <- y %>% select(2:14) 
})
alkprops <- lapply(alks, function(y) {
  y <- y %>% mutate(rowsum = rowSums(.[grep("X", names(.))], na.rm = TRUE)) %>% #add row sum
    mutate(across(2:12, .fns= function(x){x/rowsum})) %>% replace(is.na(.), 0) %>%
    rename("LENGTH" = "length")
})

alkprops <- bind_rows(alkprops) %>% rename("Year" = "year", "FL.cm" = "LENGTH") %>%
  select(-rowsum)

#alks<- rbind(alk2021numnj, alk2022numnj, alk2023numnj, alk2024numnj) %>% 

alks <- alkprops[,c(paste0("X",2:12), "FL.cm", "Year")]
################################################################################
################################### ALKs #######################################
####################### read in only one at a time #############################
```

```{r}
# Multinomial, seasonal ALK:
alk3 <- read.table(paste("C:/Users/jgorzo/OneDrive - New Jersey Office of Information Technology/Documents/data/tog/examples/hybridALKs_thru2022_final.txt",sep=""),header=TRUE,sep="\t")

################################################################################


wtdLF <- out

# get length freq proportions
#scaledWtdLF <- t(t(out)/colSums(out))

# age composition of index (storage matrix):
ACs <- matrix(NA,nrow=length(yrs),ncol=12) # 8 cols = year, plus ages 0:6+
NAAs <- matrix(NA,nrow=length(yrs),ncol=12)
```

```{r}
for(i in 1:length(yrs)) {
   .alk <- alks[alks$Year==yrs[i], 1:11] #& alk$Geo=="North"
   print(nrow(.alk))


   NAA <- colSums(.alk*wtdLF[,is.element(as.numeric(gsub("x","",colnames(wtdLF))),yrs[i])]) # numbers at age
   NAAs[i,] <- c(yrs[i],NAA)
   PAA <- NAA/sum(NAA)            # proportions at age
   ACs[i,1] <- yrs[i]
   ACs[i,2:12] <- PAA
}
#rm(.alk,alk)

#ACs;cbind(NAAs[,1],NAAs[,-1]/rowSums(NAAs[,-1]));NAAs



Sys.time()
```


### Summary:

- Use the index and SE or CV from the catch records; use the length records to apportion the data into ages.
